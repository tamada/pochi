<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Hugo 0.59.1" />
  <link rel="stylesheet" href="https://tamada.github.io/pochi/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  
  
  
  <link rel="stylesheet" href="https://tamada.github.io/pochi/css/cayman.87415a4997c8d6c666624ff26c8812f27f42b4cf5dc18c45fc8dcb0cd7d6d2f5.css">
  
  
  <link rel="stylesheet" href="https://tamada.github.io/pochi/css/pochi.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css">

<script src="https://unpkg.com/mermaid@8.4.2/dist/mermaid.min.js"></script>
<script src="https://tamada.github.io/pochi/js/pochi.js"></script>

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

  <title>Birthmarks | Pochi</title>
</head>

<body>
  <section class="page-header">
  
  <img src="https://tamada.github.io/pochiimages/pochi.png" class="avatar" alt="project_logo">
  
  <h1 class="project-name">
    pochi
  </h1>
  <h2 class="project-tagline">
    Detecting the software theft, the birthmark toolkit for the JVM platform.
  </h2>
  <nav>
    
    
      
      
      
      
      <a href="/pochi/" class="btn">Home</a>
    
      
      
      
      
      <a href="/pochi/birthmarks/" class="btn">Birthmarks</a>
    
      
      
      
      
      <a href="/pochi/description/" class="btn">Description</a>
    
      
      
      
      
      <a href="/pochi/usage/" class="btn">Usage</a>
    
      
      
      
      
      <a href="/pochi/install/" class="btn">Install</a>
    
      
      
      
      
      <a href="/pochi/about/" class="btn">About</a>
    
  </nav>
</section>

  <section class="main-content">
    
  <h1>Birthmarks</h1>
  

<ul>
<li><a href="#definition-of-birthmarks">Definition of Birthmarks</a></li>
<li><a href="#types-of-birthmarks">Types of Birthmarks</a></li>
<li><a href="#similarities">Similarities</a></li>
<li><a href="#theft-detection-process-by-birthmarks">Theft Detection Process by Birthmarks</a></li>
</ul>

<h2 id="definition-of-birthmarks">Definition of Birthmarks</h2>

<p>Let $p$, and $q$ be a given programs, and $\mathcal{B}_f(p)$ be set of characteristics extracted from $p$ by a given method $f$.
If the conditions below are met, $\mathcal{B}_f(p)$ is said to be a birthmark of $p$.</p>

<ul>
<li>Condition 1: $\mathcal{B}_f(p)$ is obtained from only program $p$.</li>
<li>Condition 2: If $q$ is a copy of $p$, then $\mathcal{B}_f(p) = \mathcal{B}_f(q)$.</li>
</ul>

<p>Condition 1 indicates that a birthmark is an information necessary for running $p$ and is not additional information.
In other words, birthmark does not require additional information in the method of a software watermark.
Condition 2 indicates that same birthmark can be obtained from a copied program.
If birthmarks $\mathcal{B}_f(p)$ and $\mathcal{B}_f(q)$ are different, this means that $q$ is not a copy of $p$.</p>

<p>Two properties known as resilience and credibility should also ideally be satisfied.</p>

<ul>
<li>Resilience

<ul>
<li>For a $p'$ obtained by an arbitrary equivalent transformation of $p$, $\mathcal{B}_f(p) = \mathcal{B}_f(p')$ is satisfied.</li>
</ul></li>
<li>Credibility

<ul>
<li>When programs $p$ and $q$ that develop independently, $\mathcal{B}_f(p)\neq \mathcal{B}_f(q)$ is satisfied.</li>
</ul></li>
</ul>

<p>Resilience property indicates a resistance of birthmark to various types of attacks.
Credibility property indicates that programs created completely independently can be differentiated even if their specifications are the same.
Because birthmarks that completely satisfy both these properties are difficult to create, in practice, birthmark strength must be set appropriately at the discretion of the user.</p>

<p class="navigation"><a href="#top" class="badge goto"><span class="label"><span class="far fa-caret-square-up label"></span> Go to</span><span class="value">top of the page</span></a></p>


<h2 id="types-of-birthmarks">Types of Birthmarks</h2>

<p>By following the definition above, many researchers proposed the different types of birthmarks.
Differences in birthmark types are caused by focusing on different parts of programs.
For example, control flows, opcode sequences, data flows, behaviors, and structures of programs are the general information for the proposed birthmarks.</p>

<p>Structures of birthmarks from extracted information also make different types of birthmarks.
For example, different types of birthmarks are proposed from opcode sequences by unmodified sequence, frequencies, and k-gram based sequences.
We categorized the structures of birthmarks into sequences, set (unordered set), vectors, and graphs.</p>

<p class="navigation"><a href="#top" class="badge goto"><span class="label"><span class="far fa-caret-square-up label"></span> Go to</span><span class="value">top of the page</span></a></p>


<h2 id="similarities">Similarities</h2>

<p>Each birthmark has own similarity calculation algorithm.
In other words, to compare $\mathcal{B}_f(p)$ and $\mathcal{B}_f(q)$ extracted from $f$ should use a certain method $\mathrm{sim}(\mathcal{B}_f(p), \mathcal{B}_f(q))$.
Besides, the range of $\mathrm{sim}(\mathcal{B}_f(p), \mathcal{B}_f(q))$ is $[0, 1]$,
Besides, the range of $\mathrm{sim}(\mathcal{B}_f(p), \mathcal{B}_f(q))$ is $[0, 1]$.
$0$ means two programs $p$ and $q$ are completely different, and $1$ means either is strongly suspects of copy from other.</p>

<p>Then, we introduce threshold $\varepsilon$ to show the suspecting rate.
We categorize resultant similarities into three groups below by $\varepsilon$.</p>

<p>\begin{eqnarray}\mathrm{sim}(\mathcal{B}_f(p), \mathcal{B}_f(q)) = \begin{cases}\geq \varepsilon      &amp; \textit{copy relation}\\ \leq 1 - \varepsilon  &amp; \textit{no copy relation}\\ \textit{otherwise}    &amp; \textit{inconclusive}\end{cases}\end{eqnarray}</p>

<p>Note that, the typical value of $\varepsilon$ is 0.75.</p>

<p class="navigation"><a href="#top" class="badge goto"><span class="label"><span class="far fa-caret-square-up label"></span> Go to</span><span class="value">top of the page</span></a></p>


<h2 id="theft-detection-process-by-birthmarks">Theft Detection Process by Birthmarks</h2>

<p>The goal of software birthmarks is detecting the suspects of copies, not prove the theft.
Therefore, the birthmark methods require to examine a huge amount of programs and to detect the suspects.</p>

<figure>
  <div class="mermaid" align="center">
graph LR
    id1(Collection);
    id2(Extraction);
    id3(Comparison);
    id4(Examination);
    id5(Post-process);
    subgraph "Birthmark System"
        id1 --> id2;
        id2 --> id3;
        id3 --> id4;
    end
    id4 --> id5;
</div>
  
  <figcaption>Figure 1: theft detection process by the birthmarks</figcaption>
  
</figure>


<p>Figure 1 shows the process of the theft detection with the birthmarks.
The following descriptions shows above phases.</p>

<p class="label" id="id1_phase">
  Note that, the users to execute the theft detection have the original (plaintiff) programs.
The user must collect the examine targets as defendant programs.
We cannot know when and where does software theft do.
Therefore, to improve the theft detection rate, we should collect programs as more as possible.
</p>



<p class="label" id="id2_phase">
  The next phase is the extraction phase for extracting birthmarks from the plaintiff and defendant programs with a given extraction method $f$.
  This phase generally requires a lot of time, because of extracting birthmarks from many programs.
</p>



<p class="label" id="id3_phase">
  In the comparison phase, we compare the plaintiff and defendant birthmarks by a round-robin, and obtain similarity list.
  The comparison count is the $m \times n$, $m$, and $n$ means the count of plaintiff and defendant birthmarks.
</p>



<p class="label" id="id4_phase">
  In the final phase in the birthmark system, we examine the pair of programs is theft or not from the similarity and both elements of birthmarks.
  Generally, this phase filters similarities by higher than EPSILON, then resultant pairs are the copy suspected programs.
</p>



<p class="label" id="id5_phase">
  After detecting the suspects by the birthmark systems, we must inspect the details of pairs to prove the theft.
  Because the birthmark methods bury no information, therefore, accidental matches may occur.
</p>



<p class="navigation"><a href="#top" class="badge goto"><span class="label"><span class="far fa-caret-square-up label"></span> Go to</span><span class="value">top of the page</span></a></p>



    <footer class="site-footer">
  <span class="site-footer-credits">
    <a href="https://github.com/tamada/pochi"><img src="https://img.shields.io/badge/GitHub-tamada/pochi-blueviolet.svg?logo=github" alt="GitHub" /></a> Made with <a href="https://gohugo.io/">Hugo</a>. Theme by <a href="https://github.com/zwbetz-gh/cayman-hugo-theme">Cayman</a>. Deployed to <a href="https://pages.github.com/">GitHub Pages</a>.
  </span>
</footer>

  </section>
  
  

</body>
</html>
